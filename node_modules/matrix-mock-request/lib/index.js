"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _expect = _interopRequireDefault(require("expect"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Construct a mock HTTP backend, heavily inspired by Angular.js.
 * @constructor
 */
class HttpBackend {
  constructor() {
    _defineProperty(this, "requests", []);

    _defineProperty(this, "expectedRequests", []);

    _defineProperty(this, "_flushPromises", []);

    _defineProperty(this, "requestFn", (opts, callback) => {
      const req = new Request(opts, callback);
      console.log(`${Date.now()} HTTP backend received request: ${req}`);
      this.requests.push(req);
      const self = this;

      const abort = function () {
        const idx = self.requests.indexOf(req);

        if (idx >= 0) {
          console.log("Aborting HTTP request: %s %s", opts.method, opts.uri);
          self.requests.splice(idx, 1);
          const e = new Error("aborted");
          e.name = "AbortError";
          req.callback(e);
        }
      };

      return {
        abort: abort
      };
    });

    _defineProperty(this, "fetchFn", (input, init) => {
      const url = new URL(input);
      const qs = Object.fromEntries(url.searchParams);
      const requestOpts = {
        uri: url.href,
        method: (init === null || init === void 0 ? void 0 : init.method) || 'GET',
        headers: init === null || init === void 0 ? void 0 : init.headers,
        body: init === null || init === void 0 ? void 0 : init.body,
        qs
      };
      return new Promise((resolve, reject) => {
        var _init$signal;

        function callback(err, response, body) {
          if (err) {
            reject(err);
            return;
          }

          resolve({
            ok: response.statusCode >= 200 && response.statusCode < 300,
            status: response.statusCode,
            json: () => JSON.parse(body),
            text: () => body,
            headers: {
              get: key => {
                var _response$headers;

                return (_response$headers = response.headers) === null || _response$headers === void 0 ? void 0 : _response$headers[key.toLowerCase()];
              },
              has: key => key.toLowerCase() in response.headers,
              keys: () => Object.keys(response.headers),
              values: () => Object.values(response.headers),
              entries: () => Object.entries(response.headers)
            },
            url: response.url
          });
        }

        ;
        const req = new Request(requestOpts, callback);
        console.log(`HTTP backend received request: ${req}`);
        this.requests.push(req);
        init === null || init === void 0 ? void 0 : (_init$signal = init.signal) === null || _init$signal === void 0 ? void 0 : _init$signal.addEventListener("abort", () => {
          const idx = this.requests.indexOf(req);

          if (idx >= 0) {
            console.log("Aborting HTTP request: %s %s", requestOpts.method, requestOpts.uri);
            this.requests.splice(idx, 1);
            const e = new Error("aborted");
            e.name = "AbortError";
            reject(e);
          }
        });
      });
    });

    _defineProperty(this, "flush", (path, numToFlush, waitTime) => {
      const self = this;
      const promise = new Promise((resolve, reject) => {
        let flushed = 0;

        if (waitTime === undefined) {
          waitTime = 100;
        }

        function log(msg) {
          console.log(`${Date.now()} flush[${path || ''}]: ${msg}`);
        }

        log("HTTP backend flushing... (path=" + path + " numToFlush=" + numToFlush + " waitTime=" + waitTime + ")");
        const endTime = waitTime + Date.now();

        const tryFlush = function () {
          try {
            _tryFlush();
          } catch (e) {
            reject(e);
          }
        };

        const _tryFlush = function () {
          // if there's more real requests and more expected requests, flush 'em.
          log(`  trying to flush => reqs=[${self.requests}] ` + `expected=[${self.expectedRequests}]`);

          if (self._takeFromQueue(path)) {
            // try again on the next tick.
            flushed += 1;

            if (numToFlush && flushed === numToFlush) {
              log(`Flushed assigned amount: ${numToFlush}`);
              resolve(flushed);
            } else {
              log(`  flushed. Trying for more.`);
              setTimeout(tryFlush, 0);
            }
          } else if ((flushed === 0 || numToFlush && numToFlush > flushed) && Date.now() < endTime) {
            // we may not have made the request yet, wait a generous amount of
            // time before giving up.
            log(`  nothing to flush yet; waiting for requests.`);
            setTimeout(tryFlush, 5);
          } else {
            if (flushed === 0) {
              log("nothing to flush; giving up");
            } else {
              log(`no more flushes after flushing ${flushed} requests`);
            }

            resolve(flushed);
          }
        };

        setTimeout(tryFlush, 0);
      });

      this._flushPromises.push(promise);

      return promise;
    });

    _defineProperty(this, "flushAllExpected", (opts = {}) => {
      opts = opts || {};

      if (this.expectedRequests.length === 0) {
        // calling flushAllExpected when there are no expectations is a
        // silly thing to do, and probably means that your test isn't
        // doing what you think it is doing (or it is racy). Hence we
        // reject this, rather than resolving immediately.
        return Promise.reject(new Error(`flushAllExpected called with an empty expectation list`));
      }

      const waitTime = opts.timeout === undefined ? 1000 : opts.timeout;
      const endTime = waitTime + Date.now();
      let flushed = 0;

      const iterate = () => {
        const timeRemaining = endTime - Date.now();

        if (timeRemaining <= 0) {
          throw new Error(`Timed out after flushing ${flushed} requests; ` + `${this.expectedRequests.length} remaining`);
        }

        return this.flush(undefined, undefined, timeRemaining).then(f => {
          flushed += f;

          if (this.expectedRequests.length === 0) {
            // we're done
            return null;
          }

          return iterate();
        });
      };

      const prom = new Promise((resolve, reject) => {
        iterate().then(() => {
          resolve(flushed);
        }, e => {
          reject(e);
        });
      });

      this._flushPromises.push(prom);

      return prom;
    });

    _defineProperty(this, "_takeFromQueue", path => {
      let req = null;
      let i;
      let j;
      let matchingReq = null;
      let expectedReq = null;
      let testResponse = null;

      for (i = 0; i < this.requests.length; i++) {
        req = this.requests[i];

        for (j = 0; j < this.expectedRequests.length; j++) {
          expectedReq = this.expectedRequests[j];

          if (path && path !== expectedReq.path) {
            continue;
          }

          if (expectedReq.method === req.method && req.path.indexOf(expectedReq.path) !== -1) {
            if (!expectedReq.data || JSON.stringify(expectedReq.data) === JSON.stringify(req.data)) {
              matchingReq = expectedReq;
              this.expectedRequests.splice(j, 1);
              break;
            }
          }
        }

        if (matchingReq) {
          // remove from request queue
          this.requests.splice(i, 1);
          i--;

          for (j = 0; j < matchingReq.checks.length; j++) {
            matchingReq.checks[j](req);
          }

          testResponse = matchingReq.response;
          console.log(`${Date.now()}    responding to ${matchingReq.path}`);
          let body = testResponse.body;

          if (Object.prototype.toString.call(body) == "[object Function]") {
            body = body(req.path, req.data, req);
          }

          if (!testResponse.rawBody) {
            body = JSON.stringify(body);
          }

          req.callback(testResponse.err, testResponse.response, body);
          matchingReq = null;
        }
      }

      if (testResponse) {
        // flushed something
        return true;
      }

      return false;
    });

    _defineProperty(this, "verifyNoOutstandingRequests", () => {
      const firstOutstandingReq = this.requests[0];

      try {
        (0, _expect.default)(this.requests.length).toEqual(0);
      } catch (error) {
        throw Error("Expected no more HTTP requests but received request to " + (firstOutstandingReq === null || firstOutstandingReq === void 0 ? void 0 : firstOutstandingReq.path));
      }
    });

    _defineProperty(this, "verifyNoOutstandingExpectation", () => {
      const firstOutstandingExpectation = this.expectedRequests[0];

      try {
        (0, _expect.default)(this.expectedRequests.length).toEqual(0);
      } catch (error) {
        throw Error("Expected no unresolved request but found unresolved request for " + (firstOutstandingExpectation === null || firstOutstandingExpectation === void 0 ? void 0 : firstOutstandingExpectation.path));
      }
    });

    _defineProperty(this, "when", (method, path, data) => {
      const pendingReq = new ExpectedRequest(method, path, data);
      this.expectedRequests.push(pendingReq);
      return pendingReq;
    });

    _defineProperty(this, "stop", () => {
      return Promise.all(this._flushPromises);
    });
  }

  /**
   * Flush any requests that have been made and are in the queue, waiting for
   * responses. Other flush methods set timers to wait for requests to arrive,
   * so if your test uses fake timers, you probably want to use this method,
   * however it is up to you to make sure the request has been made and is in
   * the queue at the point of calling this method.
   *
   * @param path The path to flush (optional) default: all.
   * @param numToFlush numToFlush The maximum number of things to flush (optional), default: all.
   *
   * @return The number of requests flushed
   */
  flushSync(path, numToFlush) {
    // Note that an alternative to this method could be to let the app pass
    // in a setTimeout function so it could give us the real setTimeout function
    // rather than the faked one. However, if you're running with fake timers
    // the only thing setting a real timer would do is allow pending promises
    // to resolve/reject. The app would have no way to know when the correct,
    // non-racy point to tick the timers is.
    console.log(`${Date.now()} HTTP backend flushing (sync)... (path=${path} ` + `numToFlush=${numToFlush})`);
    let numFlushed = 0;

    while ((!numToFlush || numFlushed < numToFlush) && this._takeFromQueue(path)) {
      ++numFlushed;
    }

    return numFlushed;
  }
  /**
   * Respond to all of the requests (flush the queue).
   * @param {string} path The path to flush (optional) default: all.
   * @param {integer} numToFlush The number of things to flush (optional), default: all.
   * @param {integer=} waitTime  The time (in ms) to wait for a request to happen.
   *    default: 100
   *
   * @return {Promise} resolves when there is nothing left to flush, with the
   *    number of requests flushed
   */


}

;

/**
 * Represents the expectation of a request.
 *
 * <p>Includes the conditions to be matched against, the checks to be made,
 * and the response to be returned.
 *
 * @constructor
 * @param {string} method
 * @param {string} path
 * @param {object?} data
 */
class ExpectedRequest {
  constructor(method, path, data) {
    this.method = method;
    this.path = path;
    this.data = data;

    _defineProperty(this, "response", null);

    _defineProperty(this, "checks", []);

    _defineProperty(this, "toString", () => {
      return this.method + " " + this.path;
    });

    _defineProperty(this, "check", fn => {
      this.checks.push(fn);
      return this;
    });

    _defineProperty(this, "respond", (code, data, rawBody) => {
      this.response = {
        response: {
          statusCode: code,
          headers: {
            'content-type': 'application/json'
          }
        },
        body: data || "",
        err: null,
        rawBody: rawBody || false
      };
    });

    _defineProperty(this, "fail", (code, err) => {
      this.response = {
        response: {
          statusCode: code,
          headers: {}
        },
        body: null,
        err: err
      };
    });
  }

}

;
/**
 * Represents a request made by the app.
 *
 * @constructor
 * @param {object} opts opts passed to request()
 * @param {function} callback
 */

class Request {
  constructor(opts, callback) {
    this.opts = opts;
    this.callback = callback;
  }

  get method() {
    return this.opts.method;
  }

  get path() {
    return this.opts.uri;
  }

  get data() {
    return this.opts.body ? JSON.parse(this.opts.body) : this.opts.body;
  }

  get rawData() {
    return this.opts.body;
  }

  get queryParams() {
    return this.opts.qs;
  }

  get headers() {
    return this.opts.headers || {};
  }

  toString() {
    return this.method + " " + this.path;
  }

}
/**
 * The HttpBackend class.
 */


var _default = HttpBackend;
exports.default = _default;