import { ICryptoCallbacks } from ".";
import { MatrixEvent } from "../models/event";
import { MatrixClient } from "../client";
import { SecretStorageKeyDescription, SecretStorageKeyTuple, SecretStorageKeyObject, AddSecretStorageKeyOpts, AccountDataClient, ServerSideSecretStorage } from "../secret-storage";
import { ISecretRequest } from "./SecretSharing";
export type { AccountDataClient as IAccountDataClient, SecretStorageKeyTuple, SecretStorageKeyObject, SECRET_STORAGE_ALGORITHM_V1_AES, } from "../secret-storage";
export type { ISecretRequest } from "./SecretSharing";
/**
 * Implements Secure Secret Storage and Sharing (MSC1946)
 *
 * @deprecated This is just a backwards-compatibility hack which will be removed soon.
 *    Use {@link SecretStorage.ServerSideSecretStorageImpl} from `../secret-storage` and/or {@link SecretSharing} from `./SecretSharing`.
 */
export declare class SecretStorage<B extends MatrixClient | undefined = MatrixClient> implements ServerSideSecretStorage {
    private readonly storageImpl;
    private readonly sharingImpl;
    constructor(accountDataAdapter: AccountDataClient, cryptoCallbacks: ICryptoCallbacks, baseApis: B);
    getDefaultKeyId(): Promise<string | null>;
    setDefaultKeyId(keyId: string): Promise<void>;
    /**
     * Add a key for encrypting secrets.
     */
    addKey(algorithm: string, opts?: AddSecretStorageKeyOpts, keyId?: string): Promise<SecretStorageKeyObject>;
    /**
     * Get the key information for a given ID.
     */
    getKey(keyId?: string | null): Promise<SecretStorageKeyTuple | null>;
    /**
     * Check whether we have a key with a given ID.
     */
    hasKey(keyId?: string): Promise<boolean>;
    /**
     * Check whether a key matches what we expect based on the key info
     */
    checkKey(key: Uint8Array, info: SecretStorageKeyDescription): Promise<boolean>;
    /**
     * Store an encrypted secret on the server
     */
    store(name: string, secret: string, keys?: string[] | null): Promise<void>;
    /**
     * Get a secret from storage.
     */
    get(name: string): Promise<string | undefined>;
    /**
     * Check if a secret is stored on the server.
     */
    isStored(name: string): Promise<Record<string, SecretStorageKeyDescription> | null>;
    /**
     * Request a secret from another device
     */
    request(name: string, devices: string[]): ISecretRequest;
    onRequestReceived(event: MatrixEvent): Promise<void>;
    onSecretReceived(event: MatrixEvent): void;
}
//# sourceMappingURL=SecretStorage.d.ts.map