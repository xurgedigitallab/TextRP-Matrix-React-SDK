{"version":3,"file":"VoiceBroadcastRecorder.js","names":["_lodash","require","_logger","_typedEventEmitter","_","_VoiceRecording","_arrays","_Singleflight","VoiceBroadcastRecorderEvent","exports","OpusHead","OpusTags","VoiceBroadcastRecorder","TypedEventEmitter","constructor","voiceRecording","targetChunkLength","_defineProperty2","default","Uint8Array","data","dataArray","headerType","Array","from","slice","isEqual","opusHead","opusTags","setCurrentChunkLength","recorderSeconds","previousChunkEndTimePosition","handleData","onDataAvailable","start","liveData","onUpdate","timeSeconds","stop","e","Singleflight","forgetAllFor","chunk","extractChunk","currentChunkLength","contentType","emit","CurrentChunkLengthUpdated","getCurrentChunkLength","chunkBuffer","concat","emitChunkIfTargetLengthReached","emitAndResetChunk","length","logger","warn","currentRecorderTime","payload","buffer","ChunkRecorded","destroy","removeAllListeners","createVoiceBroadcastRecorder","VoiceRecording","disableMaxLength","getChunkLength"],"sources":["../../../src/voice-broadcast/audio/VoiceBroadcastRecorder.ts"],"sourcesContent":["/*\r\nCopyright 2022 The Matrix.org Foundation C.I.C.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\nimport { isEqual } from \"lodash\";\r\nimport { Optional } from \"matrix-events-sdk\";\r\nimport { logger } from \"matrix-js-sdk/src/logger\";\r\nimport { TypedEventEmitter } from \"matrix-js-sdk/src/models/typed-event-emitter\";\r\n\r\nimport { getChunkLength } from \"..\";\r\nimport { IRecordingUpdate, VoiceRecording } from \"../../audio/VoiceRecording\";\r\nimport { concat } from \"../../utils/arrays\";\r\nimport { IDestroyable } from \"../../utils/IDestroyable\";\r\nimport { Singleflight } from \"../../utils/Singleflight\";\r\n\r\nexport enum VoiceBroadcastRecorderEvent {\r\n    ChunkRecorded = \"chunk_recorded\",\r\n    CurrentChunkLengthUpdated = \"current_chunk_length_updated\",\r\n}\r\n\r\ninterface EventMap {\r\n    [VoiceBroadcastRecorderEvent.ChunkRecorded]: (chunk: ChunkRecordedPayload) => void;\r\n    [VoiceBroadcastRecorderEvent.CurrentChunkLengthUpdated]: (length: number) => void;\r\n}\r\n\r\nexport interface ChunkRecordedPayload {\r\n    buffer: Uint8Array;\r\n    length: number;\r\n}\r\n\r\n// char sequence of \"OpusHead\"\r\nconst OpusHead = [79, 112, 117, 115, 72, 101, 97, 100];\r\n\r\n// char sequence of \"OpusTags\"\r\nconst OpusTags = [79, 112, 117, 115, 84, 97, 103, 115];\r\n\r\n/**\r\n * This class provides the function to seamlessly record fixed length chunks.\r\n * Subscribe with on(VoiceBroadcastRecordingEvents.ChunkRecorded, (payload: ChunkRecordedPayload) => {})\r\n * to retrieve chunks while recording.\r\n */\r\nexport class VoiceBroadcastRecorder\r\n    extends TypedEventEmitter<VoiceBroadcastRecorderEvent, EventMap>\r\n    implements IDestroyable\r\n{\r\n    private opusHead?: Uint8Array;\r\n    private opusTags?: Uint8Array;\r\n    private chunkBuffer = new Uint8Array(0);\r\n    // position of the previous chunk in seconds\r\n    private previousChunkEndTimePosition = 0;\r\n    // current chunk length in seconds\r\n    private currentChunkLength = 0;\r\n\r\n    public constructor(private voiceRecording: VoiceRecording, public readonly targetChunkLength: number) {\r\n        super();\r\n        this.voiceRecording.onDataAvailable = this.onDataAvailable;\r\n    }\r\n\r\n    public async start(): Promise<void> {\r\n        await this.voiceRecording.start();\r\n        this.voiceRecording.liveData.onUpdate((data: IRecordingUpdate) => {\r\n            this.setCurrentChunkLength(data.timeSeconds - this.previousChunkEndTimePosition);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Stops the recording and returns the remaining chunk (if any).\r\n     */\r\n    public async stop(): Promise<Optional<ChunkRecordedPayload>> {\r\n        try {\r\n            await this.voiceRecording.stop();\r\n        } catch (e) {\r\n            // Ignore if the recording raises any error.\r\n        }\r\n\r\n        // forget about that call, so that we can stop it again later\r\n        Singleflight.forgetAllFor(this.voiceRecording);\r\n        const chunk = this.extractChunk();\r\n        this.currentChunkLength = 0;\r\n        this.previousChunkEndTimePosition = 0;\r\n        return chunk;\r\n    }\r\n\r\n    public get contentType(): string {\r\n        return this.voiceRecording.contentType;\r\n    }\r\n\r\n    private setCurrentChunkLength(currentChunkLength: number): void {\r\n        if (this.currentChunkLength === currentChunkLength) return;\r\n\r\n        this.currentChunkLength = currentChunkLength;\r\n        this.emit(VoiceBroadcastRecorderEvent.CurrentChunkLengthUpdated, currentChunkLength);\r\n    }\r\n\r\n    public getCurrentChunkLength(): number {\r\n        return this.currentChunkLength;\r\n    }\r\n\r\n    private onDataAvailable = (data: ArrayBuffer): void => {\r\n        const dataArray = new Uint8Array(data);\r\n\r\n        // extract the part, that contains the header type info\r\n        const headerType = Array.from(dataArray.slice(28, 36));\r\n\r\n        if (isEqual(OpusHead, headerType)) {\r\n            // data seems to be an \"OpusHead\" header\r\n            this.opusHead = dataArray;\r\n            return;\r\n        }\r\n\r\n        if (isEqual(OpusTags, headerType)) {\r\n            // data seems to be an \"OpusTags\" header\r\n            this.opusTags = dataArray;\r\n            return;\r\n        }\r\n\r\n        this.setCurrentChunkLength(this.voiceRecording.recorderSeconds! - this.previousChunkEndTimePosition);\r\n        this.handleData(dataArray);\r\n    };\r\n\r\n    private handleData(data: Uint8Array): void {\r\n        this.chunkBuffer = concat(this.chunkBuffer, data);\r\n        this.emitChunkIfTargetLengthReached();\r\n    }\r\n\r\n    private emitChunkIfTargetLengthReached(): void {\r\n        if (this.getCurrentChunkLength() >= this.targetChunkLength) {\r\n            this.emitAndResetChunk();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Extracts the current chunk and resets the buffer.\r\n     */\r\n    private extractChunk(): Optional<ChunkRecordedPayload> {\r\n        if (this.chunkBuffer.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (!this.opusHead || !this.opusTags) {\r\n            logger.warn(\"Broadcast chunk cannot be extracted. OpusHead or OpusTags is missing.\");\r\n            return null;\r\n        }\r\n\r\n        const currentRecorderTime = this.voiceRecording.recorderSeconds!;\r\n        const payload: ChunkRecordedPayload = {\r\n            buffer: concat(this.opusHead!, this.opusTags!, this.chunkBuffer),\r\n            length: this.getCurrentChunkLength(),\r\n        };\r\n        this.chunkBuffer = new Uint8Array(0);\r\n        this.setCurrentChunkLength(0);\r\n        this.previousChunkEndTimePosition = currentRecorderTime;\r\n        return payload;\r\n    }\r\n\r\n    private emitAndResetChunk(): void {\r\n        if (this.chunkBuffer.length === 0) {\r\n            return;\r\n        }\r\n\r\n        this.emit(VoiceBroadcastRecorderEvent.ChunkRecorded, this.extractChunk()!);\r\n    }\r\n\r\n    public destroy(): void {\r\n        this.removeAllListeners();\r\n        this.voiceRecording.destroy();\r\n    }\r\n}\r\n\r\nexport const createVoiceBroadcastRecorder = (): VoiceBroadcastRecorder => {\r\n    const voiceRecording = new VoiceRecording();\r\n    voiceRecording.disableMaxLength();\r\n    return new VoiceBroadcastRecorder(voiceRecording, getChunkLength());\r\n};\r\n"],"mappings":"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"}