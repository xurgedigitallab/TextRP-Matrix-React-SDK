{"version":3,"file":"RoomNotifs.js","names":["_pushprocessor","require","_room","_PushRules","_NotificationColor","_RoomStatusBar","_Unread","_membership","_SettingsStore","_interopRequireDefault","RoomNotifState","exports","getRoomNotifsState","client","roomId","isGuest","AllMessages","muteRule","findOverrideMuteRule","Mute","roomRule","getRoomPushRule","err","enabled","isMuteRule","MentionsOnly","actionsObject","PushProcessor","actionListToActionsObject","actions","tweaks","sound","AllMessagesLoud","setRoomNotifsState","newState","setRoomNotifsStateMuted","setRoomNotifsStateUnmuted","getUnreadNotificationCount","room","type","threadId","notificationCount","getThreadUnreadNotificationCount","msc3946ProcessDynamicPredecessor","SettingsStore","getValue","predecessor","findPredecessor","oldRoomId","oldRoom","getRoom","NotificationCountType","Highlight","cli","promises","push","deletePushRule","PushRuleKind","RoomSpecific","rule_id","addPushRule","Override","conditions","kind","ConditionKind","EventMatch","key","pattern","PushRuleActionName","DontNotify","Promise","all","overrideMuteRule","setPushRuleEnabled","Notify","set_tweak","TweakName","Sound","value","pushRules","global","override","rule","isRuleRoomMuteRuleForRoomId","isRuleMaybeRoomMuteRule","length","cond","determineUnreadState","symbol","count","color","NotificationColor","None","getUnsentMessages","Unsent","getEffectiveMembership","getMyMembership","EffectiveMembership","Invite","Red","redNotifs","greyNotifs","Total","trueCount","Grey","hasUnread","doesRoomOrThreadHaveUnreadMessages","getThread","doesRoomHaveUnreadMessages","Bold"],"sources":["../src/RoomNotifs.ts"],"sourcesContent":["/*\r\nCopyright 2016, 2019, 2023 The Matrix.org Foundation C.I.C.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\nimport { PushProcessor } from \"matrix-js-sdk/src/pushprocessor\";\r\nimport { NotificationCountType } from \"matrix-js-sdk/src/models/room\";\r\nimport { ConditionKind, PushRuleActionName, PushRuleKind, TweakName } from \"matrix-js-sdk/src/@types/PushRules\";\r\n\r\nimport type { IPushRule } from \"matrix-js-sdk/src/@types/PushRules\";\r\nimport type { Room } from \"matrix-js-sdk/src/models/room\";\r\nimport type { MatrixClient } from \"matrix-js-sdk/src/matrix\";\r\nimport { NotificationColor } from \"./stores/notifications/NotificationColor\";\r\nimport { getUnsentMessages } from \"./components/structures/RoomStatusBar\";\r\nimport { doesRoomHaveUnreadMessages, doesRoomOrThreadHaveUnreadMessages } from \"./Unread\";\r\nimport { EffectiveMembership, getEffectiveMembership } from \"./utils/membership\";\r\nimport SettingsStore from \"./settings/SettingsStore\";\r\n\r\nexport enum RoomNotifState {\r\n    AllMessagesLoud = \"all_messages_loud\",\r\n    AllMessages = \"all_messages\",\r\n    MentionsOnly = \"mentions_only\",\r\n    Mute = \"mute\",\r\n}\r\n\r\nexport function getRoomNotifsState(client: MatrixClient, roomId: string): RoomNotifState | null {\r\n    if (client.isGuest()) return RoomNotifState.AllMessages;\r\n\r\n    // look through the override rules for a rule affecting this room:\r\n    // if one exists, it will take precedence.\r\n    const muteRule = findOverrideMuteRule(client, roomId);\r\n    if (muteRule) {\r\n        return RoomNotifState.Mute;\r\n    }\r\n\r\n    // for everything else, look at the room rule.\r\n    let roomRule: IPushRule | undefined;\r\n    try {\r\n        roomRule = client.getRoomPushRule(\"global\", roomId);\r\n    } catch (err) {\r\n        // Possible that the client doesn't have pushRules yet. If so, it\r\n        // hasn't started either, so indicate that this room is not notifying.\r\n        return null;\r\n    }\r\n\r\n    // XXX: We have to assume the default is to notify for all messages\r\n    // (in particular this will be 'wrong' for one to one rooms because\r\n    // they will notify loudly for all messages)\r\n    if (!roomRule?.enabled) return RoomNotifState.AllMessages;\r\n\r\n    // a mute at the room level will still allow mentions\r\n    // to notify\r\n    if (isMuteRule(roomRule)) return RoomNotifState.MentionsOnly;\r\n\r\n    const actionsObject = PushProcessor.actionListToActionsObject(roomRule.actions);\r\n    if (actionsObject.tweaks.sound) return RoomNotifState.AllMessagesLoud;\r\n\r\n    return null;\r\n}\r\n\r\nexport function setRoomNotifsState(client: MatrixClient, roomId: string, newState: RoomNotifState): Promise<void> {\r\n    if (newState === RoomNotifState.Mute) {\r\n        return setRoomNotifsStateMuted(client, roomId);\r\n    } else {\r\n        return setRoomNotifsStateUnmuted(client, roomId, newState);\r\n    }\r\n}\r\n\r\nexport function getUnreadNotificationCount(room: Room, type: NotificationCountType, threadId?: string): number {\r\n    let notificationCount = !!threadId\r\n        ? room.getThreadUnreadNotificationCount(threadId, type)\r\n        : room.getUnreadNotificationCount(type);\r\n\r\n    // Check notification counts in the old room just in case there's some lost\r\n    // there. We only go one level down to avoid performance issues, and theory\r\n    // is that 1st generation rooms will have already been read by the 3rd generation.\r\n    const msc3946ProcessDynamicPredecessor = SettingsStore.getValue(\"feature_dynamic_room_predecessors\");\r\n    const predecessor = room.findPredecessor(msc3946ProcessDynamicPredecessor);\r\n    // Exclude threadId, as the same thread can't continue over a room upgrade\r\n    if (!threadId && predecessor?.roomId) {\r\n        const oldRoomId = predecessor.roomId;\r\n        const oldRoom = room.client.getRoom(oldRoomId);\r\n        if (oldRoom) {\r\n            // We only ever care if there's highlights in the old room. No point in\r\n            // notifying the user for unread messages because they would have extreme\r\n            // difficulty changing their notification preferences away from \"All Messages\"\r\n            // and \"Noisy\".\r\n            notificationCount += oldRoom.getUnreadNotificationCount(NotificationCountType.Highlight);\r\n        }\r\n    }\r\n\r\n    return notificationCount;\r\n}\r\n\r\nfunction setRoomNotifsStateMuted(cli: MatrixClient, roomId: string): Promise<any> {\r\n    const promises: Promise<unknown>[] = [];\r\n\r\n    // delete the room rule\r\n    const roomRule = cli.getRoomPushRule(\"global\", roomId);\r\n    if (roomRule) {\r\n        promises.push(cli.deletePushRule(\"global\", PushRuleKind.RoomSpecific, roomRule.rule_id));\r\n    }\r\n\r\n    // add/replace an override rule to squelch everything in this room\r\n    // NB. We use the room ID as the name of this rule too, although this\r\n    // is an override rule, not a room rule: it still pertains to this room\r\n    // though, so using the room ID as the rule ID is logical and prevents\r\n    // duplicate copies of the rule.\r\n    promises.push(\r\n        cli.addPushRule(\"global\", PushRuleKind.Override, roomId, {\r\n            conditions: [\r\n                {\r\n                    kind: ConditionKind.EventMatch,\r\n                    key: \"room_id\",\r\n                    pattern: roomId,\r\n                },\r\n            ],\r\n            actions: [PushRuleActionName.DontNotify],\r\n        }),\r\n    );\r\n\r\n    return Promise.all(promises);\r\n}\r\n\r\nfunction setRoomNotifsStateUnmuted(cli: MatrixClient, roomId: string, newState: RoomNotifState): Promise<any> {\r\n    const promises: Promise<unknown>[] = [];\r\n\r\n    const overrideMuteRule = findOverrideMuteRule(cli, roomId);\r\n    if (overrideMuteRule) {\r\n        promises.push(cli.deletePushRule(\"global\", PushRuleKind.Override, overrideMuteRule.rule_id));\r\n    }\r\n\r\n    if (newState === RoomNotifState.AllMessages) {\r\n        const roomRule = cli.getRoomPushRule(\"global\", roomId);\r\n        if (roomRule) {\r\n            promises.push(cli.deletePushRule(\"global\", PushRuleKind.RoomSpecific, roomRule.rule_id));\r\n        }\r\n    } else if (newState === RoomNotifState.MentionsOnly) {\r\n        promises.push(\r\n            cli.addPushRule(\"global\", PushRuleKind.RoomSpecific, roomId, {\r\n                actions: [PushRuleActionName.DontNotify],\r\n            }),\r\n        );\r\n        // https://matrix.org/jira/browse/SPEC-400\r\n        promises.push(cli.setPushRuleEnabled(\"global\", PushRuleKind.RoomSpecific, roomId, true));\r\n    } else if (newState === RoomNotifState.AllMessagesLoud) {\r\n        promises.push(\r\n            cli.addPushRule(\"global\", PushRuleKind.RoomSpecific, roomId, {\r\n                actions: [\r\n                    PushRuleActionName.Notify,\r\n                    {\r\n                        set_tweak: TweakName.Sound,\r\n                        value: \"default\",\r\n                    },\r\n                ],\r\n            }),\r\n        );\r\n        // https://matrix.org/jira/browse/SPEC-400\r\n        promises.push(cli.setPushRuleEnabled(\"global\", PushRuleKind.RoomSpecific, roomId, true));\r\n    }\r\n\r\n    return Promise.all(promises);\r\n}\r\n\r\nfunction findOverrideMuteRule(cli: MatrixClient | undefined, roomId: string): IPushRule | null {\r\n    if (!cli?.pushRules?.global?.override) {\r\n        return null;\r\n    }\r\n    for (const rule of cli.pushRules.global.override) {\r\n        if (rule.enabled && isRuleRoomMuteRuleForRoomId(roomId, rule)) {\r\n            return rule;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Checks if a given rule is a room mute rule as implemented by EW\r\n * - matches every event in one room (one condition that is an event match on roomId)\r\n * - silences notifications (one action that is `DontNotify`)\r\n * @param rule - push rule\r\n * @returns {boolean} - true when rule mutes a room\r\n */\r\nexport function isRuleMaybeRoomMuteRule(rule: IPushRule): boolean {\r\n    return (\r\n        // matches every event in one room\r\n        rule.conditions?.length === 1 &&\r\n        rule.conditions[0].kind === ConditionKind.EventMatch &&\r\n        rule.conditions[0].key === \"room_id\" &&\r\n        // silences notifications\r\n        isMuteRule(rule)\r\n    );\r\n}\r\n\r\n/**\r\n * Checks if a given rule is a room mute rule as implemented by EW\r\n * @param roomId - id of room to match\r\n * @param rule - push rule\r\n * @returns {boolean} true when rule mutes the given room\r\n */\r\nfunction isRuleRoomMuteRuleForRoomId(roomId: string, rule: IPushRule): boolean {\r\n    if (!isRuleMaybeRoomMuteRule(rule)) {\r\n        return false;\r\n    }\r\n    // isRuleMaybeRoomMuteRule checks this condition exists\r\n    const cond = rule.conditions![0]!;\r\n    return cond.pattern === roomId;\r\n}\r\n\r\nfunction isMuteRule(rule: IPushRule): boolean {\r\n    return rule.actions.length === 1 && rule.actions[0] === PushRuleActionName.DontNotify;\r\n}\r\n\r\nexport function determineUnreadState(\r\n    room?: Room,\r\n    threadId?: string,\r\n): { color: NotificationColor; symbol: string | null; count: number } {\r\n    if (!room) {\r\n        return { symbol: null, count: 0, color: NotificationColor.None };\r\n    }\r\n\r\n    if (getUnsentMessages(room, threadId).length > 0) {\r\n        return { symbol: \"!\", count: 1, color: NotificationColor.Unsent };\r\n    }\r\n\r\n    if (getEffectiveMembership(room.getMyMembership()) === EffectiveMembership.Invite) {\r\n        return { symbol: \"!\", count: 1, color: NotificationColor.Red };\r\n    }\r\n\r\n    if (getRoomNotifsState(room.client, room.roomId) === RoomNotifState.Mute) {\r\n        return { symbol: null, count: 0, color: NotificationColor.None };\r\n    }\r\n\r\n    const redNotifs = getUnreadNotificationCount(room, NotificationCountType.Highlight, threadId);\r\n    const greyNotifs = getUnreadNotificationCount(room, NotificationCountType.Total, threadId);\r\n\r\n    const trueCount = greyNotifs || redNotifs;\r\n    if (redNotifs > 0) {\r\n        return { symbol: null, count: trueCount, color: NotificationColor.Red };\r\n    }\r\n\r\n    if (greyNotifs > 0) {\r\n        return { symbol: null, count: trueCount, color: NotificationColor.Grey };\r\n    }\r\n\r\n    // We don't have any notified messages, but we might have unread messages. Let's\r\n    // find out.\r\n    let hasUnread = false;\r\n    if (threadId) hasUnread = doesRoomOrThreadHaveUnreadMessages(room.getThread(threadId)!);\r\n    else hasUnread = doesRoomHaveUnreadMessages(room);\r\n\r\n    return {\r\n        symbol: null,\r\n        count: trueCount,\r\n        color: hasUnread ? NotificationColor.Bold : NotificationColor.None,\r\n    };\r\n}\r\n"],"mappings":"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"}