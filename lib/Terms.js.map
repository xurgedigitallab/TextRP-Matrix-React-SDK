{"version":3,"file":"Terms.js","names":["_classnames","_interopRequireDefault","require","_logger","_Modal","_TermsDialog","TermsNotSignedError","Error","exports","Service","constructor","serviceType","baseUrl","accessToken","startTermsFlow","client","services","interactionCallback","arguments","length","undefined","dialogTermsInteractionCallback","termsPromises","map","s","getTerms","terms","Promise","all","policiesAndServicePairs","t","i","service","policies","currentAcceptedTerms","getAccountData","agreedUrlSet","getContent","accepted","Set","unagreedPoliciesAndServicePairs","unagreedPolicies","policyName","policy","Object","entries","policyAgreed","lang","keys","has","url","push","numAcceptedBeforeAgreement","size","newlyAgreedUrls","logger","log","forEach","add","newAcceptedTerms","Array","from","setAccountData","agreePromises","policiesAndService","urlsForService","filter","values","resolve","agreeToTerms","agreedUrls","extraClassNames","finished","Modal","createDialog","TermsDialog","classNames","done","_agreedUrls"],"sources":["../src/Terms.ts"],"sourcesContent":["/*\r\nCopyright 2019, 2021 The Matrix.org Foundation C.I.C.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\nimport classNames from \"classnames\";\r\nimport { SERVICE_TYPES } from \"matrix-js-sdk/src/service-types\";\r\nimport { logger } from \"matrix-js-sdk/src/logger\";\r\nimport { MatrixClient } from \"matrix-js-sdk/src/matrix\";\r\n\r\nimport Modal from \"./Modal\";\r\nimport TermsDialog from \"./components/views/dialogs/TermsDialog\";\r\n\r\nexport class TermsNotSignedError extends Error {}\r\n\r\n/**\r\n * Class representing a service that may have terms & conditions that\r\n * require agreement from the user before the user can use that service.\r\n */\r\nexport class Service {\r\n    /**\r\n     * @param {MatrixClient.SERVICE_TYPES} serviceType The type of service\r\n     * @param {string} baseUrl The Base URL of the service (ie. before '/_matrix')\r\n     * @param {string} accessToken The user's access token for the service\r\n     */\r\n    public constructor(public serviceType: SERVICE_TYPES, public baseUrl: string, public accessToken: string) {}\r\n}\r\n\r\nexport interface LocalisedPolicy {\r\n    name: string;\r\n    url: string;\r\n}\r\n\r\nexport interface Policy {\r\n    // @ts-ignore: No great way to express indexed types together with other keys\r\n    version: string;\r\n    [lang: string]: LocalisedPolicy;\r\n}\r\n\r\nexport type Policies = {\r\n    [policy: string]: Policy;\r\n};\r\n\r\nexport type ServicePolicyPair = {\r\n    policies: Policies;\r\n    service: Service;\r\n};\r\n\r\nexport type TermsInteractionCallback = (\r\n    policiesAndServicePairs: ServicePolicyPair[],\r\n    agreedUrls: string[],\r\n    extraClassNames?: string,\r\n) => Promise<string[]>;\r\n\r\n/**\r\n * Start a flow where the user is presented with terms & conditions for some services\r\n *\r\n * @param client The Matrix Client instance of the logged-in user\r\n * @param {Service[]} services Object with keys 'serviceType', 'baseUrl', 'accessToken'\r\n * @param {function} interactionCallback Function called with:\r\n *      * an array of { service: {Service}, policies: {terms response from API} }\r\n *      * an array of URLs the user has already agreed to\r\n *     Must return a Promise which resolves with a list of URLs of documents agreed to\r\n * @returns {Promise} resolves when the user agreed to all necessary terms or rejects\r\n *     if they cancel.\r\n */\r\nexport async function startTermsFlow(\r\n    client: MatrixClient,\r\n    services: Service[],\r\n    interactionCallback: TermsInteractionCallback = dialogTermsInteractionCallback,\r\n): Promise<void> {\r\n    const termsPromises = services.map((s) => client.getTerms(s.serviceType, s.baseUrl));\r\n\r\n    /*\r\n     * a /terms response looks like:\r\n     * {\r\n     *     \"policies\": {\r\n     *         \"terms_of_service\": {\r\n     *             \"version\": \"2.0\",\r\n     *              \"en\": {\r\n     *                 \"name\": \"Terms of Service\",\r\n     *                 \"url\": \"https://example.org/somewhere/terms-2.0-en.html\"\r\n     *             },\r\n     *             \"fr\": {\r\n     *                 \"name\": \"Conditions d'utilisation\",\r\n     *                 \"url\": \"https://example.org/somewhere/terms-2.0-fr.html\"\r\n     *             }\r\n     *         }\r\n     *     }\r\n     * }\r\n     */\r\n\r\n    const terms: { policies: Policies }[] = await Promise.all(termsPromises);\r\n    const policiesAndServicePairs = terms.map((t, i) => {\r\n        return { service: services[i], policies: t.policies };\r\n    });\r\n\r\n    // fetch the set of agreed policy URLs from account data\r\n    const currentAcceptedTerms = await client.getAccountData(\"m.accepted_terms\");\r\n    let agreedUrlSet: Set<string>;\r\n    if (!currentAcceptedTerms || !currentAcceptedTerms.getContent() || !currentAcceptedTerms.getContent().accepted) {\r\n        agreedUrlSet = new Set();\r\n    } else {\r\n        agreedUrlSet = new Set(currentAcceptedTerms.getContent().accepted);\r\n    }\r\n\r\n    // remove any policies the user has already agreed to and any services where\r\n    // they've already agreed to all the policies\r\n    // NB. it could be nicer to show the user stuff they've already agreed to,\r\n    // but then they'd assume they can un-check the boxes to un-agree to a policy,\r\n    // but that is not a thing the API supports, so probably best to just show\r\n    // things they've not agreed to yet.\r\n    const unagreedPoliciesAndServicePairs: ServicePolicyPair[] = [];\r\n    for (const { service, policies } of policiesAndServicePairs) {\r\n        const unagreedPolicies: Policies = {};\r\n        for (const [policyName, policy] of Object.entries(policies)) {\r\n            let policyAgreed = false;\r\n            for (const lang of Object.keys(policy)) {\r\n                if (lang === \"version\") continue;\r\n                if (agreedUrlSet.has(policy[lang].url)) {\r\n                    policyAgreed = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!policyAgreed) unagreedPolicies[policyName] = policy;\r\n        }\r\n        if (Object.keys(unagreedPolicies).length > 0) {\r\n            unagreedPoliciesAndServicePairs.push({ service, policies: unagreedPolicies });\r\n        }\r\n    }\r\n\r\n    // if there's anything left to agree to, prompt the user\r\n    const numAcceptedBeforeAgreement = agreedUrlSet.size;\r\n    if (unagreedPoliciesAndServicePairs.length > 0) {\r\n        const newlyAgreedUrls = await interactionCallback(unagreedPoliciesAndServicePairs, [...agreedUrlSet]);\r\n        logger.log(\"User has agreed to URLs\", newlyAgreedUrls);\r\n        // Merge with previously agreed URLs\r\n        newlyAgreedUrls.forEach((url) => agreedUrlSet.add(url));\r\n    } else {\r\n        logger.log(\"User has already agreed to all required policies\");\r\n    }\r\n\r\n    // We only ever add to the set of URLs, so if anything has changed then we'd see a different length\r\n    if (agreedUrlSet.size !== numAcceptedBeforeAgreement) {\r\n        const newAcceptedTerms = { accepted: Array.from(agreedUrlSet) };\r\n        await client.setAccountData(\"m.accepted_terms\", newAcceptedTerms);\r\n    }\r\n\r\n    const agreePromises = policiesAndServicePairs.map((policiesAndService) => {\r\n        // filter the agreed URL list for ones that are actually for this service\r\n        // (one URL may be used for multiple services)\r\n        // Not a particularly efficient loop but probably fine given the numbers involved\r\n        const urlsForService = Array.from(agreedUrlSet).filter((url) => {\r\n            for (const policy of Object.values(policiesAndService.policies)) {\r\n                for (const lang of Object.keys(policy)) {\r\n                    if (lang === \"version\") continue;\r\n                    if (policy[lang].url === url) return true;\r\n                }\r\n            }\r\n            return false;\r\n        });\r\n\r\n        if (urlsForService.length === 0) return Promise.resolve();\r\n\r\n        return client.agreeToTerms(\r\n            policiesAndService.service.serviceType,\r\n            policiesAndService.service.baseUrl,\r\n            policiesAndService.service.accessToken,\r\n            urlsForService,\r\n        );\r\n    });\r\n    await Promise.all(agreePromises);\r\n}\r\n\r\nexport async function dialogTermsInteractionCallback(\r\n    policiesAndServicePairs: {\r\n        service: Service;\r\n        policies: { [policy: string]: Policy };\r\n    }[],\r\n    agreedUrls: string[],\r\n    extraClassNames?: string,\r\n): Promise<string[]> {\r\n    logger.log(\"Terms that need agreement\", policiesAndServicePairs);\r\n\r\n    const { finished } = Modal.createDialog(\r\n        TermsDialog,\r\n        {\r\n            policiesAndServicePairs,\r\n            agreedUrls,\r\n        },\r\n        classNames(\"mx_TermsDialog\", extraClassNames),\r\n    );\r\n\r\n    const [done, _agreedUrls] = await finished;\r\n    if (!done || !_agreedUrls) {\r\n        throw new TermsNotSignedError();\r\n    }\r\n    return _agreedUrls;\r\n}\r\n"],"mappings":"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"}