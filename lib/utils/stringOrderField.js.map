{"version":3,"file":"stringOrderField.js","names":["_utils","require","_arrays","midPointsBetweenStrings","a","b","count","maxLen","alphabet","arguments","length","undefined","DEFAULT_ALPHABET","padN","Math","min","max","padA","alphabetPad","padB","baseA","stringToBase","baseB","BigInt","step","start","Array","fill","map","_","i","baseToString","reorderLexicographically","orders","fromIndex","toIndex","ordersWithIndices","order","index","newOrder","moveElement","orderToLeftUndefined","leftBoundIdx","rightBoundIdx","canMoveLeft","nextBase","Number","MAX_VALUE","j","firstOrderBase","bigToIndex","canDisplaceRight","canMoveRight","prevBase","MIN_VALUE","leftDiff","MAX_SAFE_INTEGER","rightDiff","prevOrder","nextOrder","charAt","repeat","changes","exports"],"sources":["../../src/utils/stringOrderField.ts"],"sourcesContent":["/*\r\nCopyright 2021 The Matrix.org Foundation C.I.C.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\nimport { alphabetPad, baseToString, stringToBase, DEFAULT_ALPHABET } from \"matrix-js-sdk/src/utils\";\r\n\r\nimport { moveElement } from \"./arrays\";\r\n\r\nexport function midPointsBetweenStrings(\r\n    a: string,\r\n    b: string,\r\n    count: number,\r\n    maxLen: number,\r\n    alphabet = DEFAULT_ALPHABET,\r\n): string[] {\r\n    const padN = Math.min(Math.max(a.length, b.length), maxLen);\r\n    const padA = alphabetPad(a, padN, alphabet);\r\n    const padB = alphabetPad(b, padN, alphabet);\r\n    const baseA = stringToBase(padA, alphabet);\r\n    const baseB = stringToBase(padB, alphabet);\r\n\r\n    if (baseB - baseA - BigInt(1) < count) {\r\n        if (padN < maxLen) {\r\n            // this recurses once at most due to the new limit of n+1\r\n            return midPointsBetweenStrings(\r\n                alphabetPad(padA, padN + 1, alphabet),\r\n                alphabetPad(padB, padN + 1, alphabet),\r\n                count,\r\n                padN + 1,\r\n                alphabet,\r\n            );\r\n        }\r\n        return [];\r\n    }\r\n\r\n    const step = (baseB - baseA) / BigInt(count + 1);\r\n    const start = BigInt(baseA + step);\r\n    return Array(count)\r\n        .fill(undefined)\r\n        .map((_, i) => baseToString(start + BigInt(i) * step, alphabet));\r\n}\r\n\r\ninterface IEntry {\r\n    index: number;\r\n    order?: string;\r\n}\r\n\r\nexport const reorderLexicographically = (\r\n    orders: Array<string | undefined>,\r\n    fromIndex: number,\r\n    toIndex: number,\r\n    maxLen = 50,\r\n): IEntry[] => {\r\n    // sanity check inputs\r\n    if (fromIndex < 0 || toIndex < 0 || fromIndex > orders.length || toIndex > orders.length || fromIndex === toIndex) {\r\n        return [];\r\n    }\r\n\r\n    // zip orders with their indices to simplify later index wrangling\r\n    const ordersWithIndices: IEntry[] = orders.map((order, index) => ({ index, order }));\r\n    // apply the fundamental order update to the zipped array\r\n    const newOrder = moveElement(ordersWithIndices, fromIndex, toIndex);\r\n\r\n    // check if we have to fill undefined orders to complete placement\r\n    const orderToLeftUndefined = newOrder[toIndex - 1]?.order === undefined;\r\n\r\n    let leftBoundIdx = toIndex;\r\n    let rightBoundIdx = toIndex;\r\n\r\n    let canMoveLeft = true;\r\n    const nextBase =\r\n        newOrder[toIndex + 1]?.order !== undefined\r\n            ? stringToBase(newOrder[toIndex + 1].order!)\r\n            : BigInt(Number.MAX_VALUE);\r\n\r\n    // check how far left we would have to mutate to fit in that direction\r\n    for (let i = toIndex - 1, j = 1; i >= 0; i--, j++) {\r\n        if (newOrder[i]?.order !== undefined && nextBase - stringToBase(newOrder[i].order!) > j) break;\r\n        leftBoundIdx = i;\r\n    }\r\n\r\n    // verify the left move would be sufficient\r\n    const firstOrderBase = newOrder[0].order === undefined ? undefined : stringToBase(newOrder[0].order);\r\n    const bigToIndex = BigInt(toIndex);\r\n    if (\r\n        leftBoundIdx === 0 &&\r\n        firstOrderBase !== undefined &&\r\n        nextBase - firstOrderBase <= bigToIndex &&\r\n        firstOrderBase <= bigToIndex\r\n    ) {\r\n        canMoveLeft = false;\r\n    }\r\n\r\n    const canDisplaceRight = !orderToLeftUndefined;\r\n    let canMoveRight = canDisplaceRight;\r\n    if (canDisplaceRight) {\r\n        const prevBase =\r\n            newOrder[toIndex - 1]?.order !== undefined\r\n                ? stringToBase(newOrder[toIndex - 1].order!)\r\n                : BigInt(Number.MIN_VALUE);\r\n\r\n        // check how far right we would have to mutate to fit in that direction\r\n        for (let i = toIndex + 1, j = 1; i < newOrder.length; i++, j++) {\r\n            if (newOrder[i]?.order === undefined || stringToBase(newOrder[i].order!) - prevBase > j) break;\r\n            rightBoundIdx = i;\r\n        }\r\n\r\n        // verify the right move would be sufficient\r\n        if (\r\n            rightBoundIdx === newOrder.length - 1 &&\r\n            (newOrder[rightBoundIdx]?.order ? stringToBase(newOrder[rightBoundIdx].order!) : BigInt(Number.MAX_VALUE)) -\r\n                prevBase <=\r\n                rightBoundIdx - toIndex\r\n        ) {\r\n            canMoveRight = false;\r\n        }\r\n    }\r\n\r\n    // pick the cheaper direction\r\n    const leftDiff = canMoveLeft ? toIndex - leftBoundIdx : Number.MAX_SAFE_INTEGER;\r\n    const rightDiff = canMoveRight ? rightBoundIdx - toIndex : Number.MAX_SAFE_INTEGER;\r\n    if (orderToLeftUndefined || leftDiff < rightDiff) {\r\n        rightBoundIdx = toIndex;\r\n    } else {\r\n        leftBoundIdx = toIndex;\r\n    }\r\n\r\n    const prevOrder = newOrder[leftBoundIdx - 1]?.order ?? \"\";\r\n    const nextOrder =\r\n        newOrder[rightBoundIdx + 1]?.order ??\r\n        DEFAULT_ALPHABET.charAt(DEFAULT_ALPHABET.length - 1).repeat(prevOrder.length || 1);\r\n\r\n    const changes = midPointsBetweenStrings(prevOrder, nextOrder, 1 + rightBoundIdx - leftBoundIdx, maxLen);\r\n\r\n    return changes.map((order, i) => ({\r\n        index: newOrder[leftBoundIdx + i].index,\r\n        order,\r\n    }));\r\n};\r\n"],"mappings":"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"}