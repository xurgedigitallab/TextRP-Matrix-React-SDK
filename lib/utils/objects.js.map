{"version":3,"file":"objects.js","names":["_arrays","require","objectExcluding","a","props","tempMap","Map","Object","entries","prop","delete","Array","from","reduce","c","_ref","k","v","objectWithOnly","existingProps","keys","diff","arrayDiff","removed","length","objectShallowClone","propertyCloner","newObj","objectHasDiff","b","aKeys","bKeys","possibleChanges","arrayIntersection","some","objectDiff","keyDiff","changes","filter","changed","added","objectKeyChanges","arrayUnion","objectClone","obj","JSON","parse","stringify","isObject","item","isArray"],"sources":["../../src/utils/objects.ts"],"sourcesContent":["/*\r\nCopyright 2020, 2021 The Matrix.org Foundation C.I.C.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\nimport { arrayDiff, arrayUnion, arrayIntersection } from \"./arrays\";\r\n\r\ntype ObjectExcluding<O extends {}, P extends (keyof O)[]> = { [k in Exclude<keyof O, P[number]>]: O[k] };\r\n\r\n/**\r\n * Gets a new object which represents the provided object, excluding some properties.\r\n * @param a The object to strip properties of. Must be defined.\r\n * @param props The property names to remove.\r\n * @returns The new object without the provided properties.\r\n */\r\nexport function objectExcluding<O extends {}, P extends Array<keyof O>>(a: O, props: P): ObjectExcluding<O, P> {\r\n    // We use a Map to avoid hammering the `delete` keyword, which is slow and painful.\r\n    const tempMap = new Map<keyof O, any>(Object.entries(a) as [keyof O, any][]);\r\n    for (const prop of props) {\r\n        tempMap.delete(prop);\r\n    }\r\n\r\n    // Convert the map to an object again\r\n    return Array.from(tempMap.entries()).reduce((c, [k, v]) => {\r\n        c[k] = v;\r\n        return c;\r\n    }, {} as O);\r\n}\r\n\r\n/**\r\n * Gets a new object which represents the provided object, with only some properties\r\n * included.\r\n * @param a The object to clone properties of. Must be defined.\r\n * @param props The property names to keep.\r\n * @returns The new object with only the provided properties.\r\n */\r\nexport function objectWithOnly<O extends {}, P extends Array<keyof O>>(a: O, props: P): { [k in P[number]]: O[k] } {\r\n    const existingProps = Object.keys(a) as (keyof O)[];\r\n    const diff = arrayDiff(existingProps, props);\r\n    if (diff.removed.length === 0) {\r\n        return objectShallowClone(a);\r\n    } else {\r\n        return objectExcluding(a, diff.removed) as { [k in P[number]]: O[k] };\r\n    }\r\n}\r\n\r\n/**\r\n * Clones an object to a caller-controlled depth. When a propertyCloner is supplied, the\r\n * object's properties will be passed through it with the return value used as the new\r\n * object's type. This is intended to be used to deep clone a reference, but without\r\n * having to deep clone the entire object. This function is safe to call recursively within\r\n * the propertyCloner.\r\n * @param a The object to clone. Must be defined.\r\n * @param propertyCloner The function to clone the properties of the object with, optionally.\r\n * First argument is the property key with the second being the current value.\r\n * @returns A cloned object.\r\n */\r\nexport function objectShallowClone<O extends {}>(a: O, propertyCloner?: (k: keyof O, v: O[keyof O]) => any): O {\r\n    const newObj = {} as O;\r\n    for (const [k, v] of Object.entries(a) as [keyof O, O[keyof O]][]) {\r\n        newObj[k] = v;\r\n        if (propertyCloner) {\r\n            newObj[k] = propertyCloner(k, v);\r\n        }\r\n    }\r\n    return newObj;\r\n}\r\n\r\n/**\r\n * Determines if any keys were added, removed, or changed between two objects.\r\n * For changes, simple triple equal comparisons are done, not in-depth\r\n * tree checking.\r\n * @param a The first object. Must be defined.\r\n * @param b The second object. Must be defined.\r\n * @returns True if there's a difference between the objects, false otherwise\r\n */\r\nexport function objectHasDiff<O extends {}>(a: O, b: O): boolean {\r\n    if (a === b) return false;\r\n    const aKeys = Object.keys(a);\r\n    const bKeys = Object.keys(b);\r\n    if (aKeys.length !== bKeys.length) return true;\r\n    const possibleChanges = arrayIntersection(aKeys, bKeys) as Array<keyof O>;\r\n    // if the amalgamation of both sets of keys has the a different length to the inputs then there must be a change\r\n    if (possibleChanges.length !== aKeys.length) return true;\r\n\r\n    return possibleChanges.some((k) => a[k] !== b[k]);\r\n}\r\n\r\ntype Diff<K> = { changed: K[]; added: K[]; removed: K[] };\r\n\r\n/**\r\n * Determines the keys added, changed, and removed between two objects.\r\n * For changes, simple triple equal comparisons are done, not in-depth\r\n * tree checking.\r\n * @param a The first object. Must be defined.\r\n * @param b The second object. Must be defined.\r\n * @returns The difference between the keys of each object.\r\n */\r\nexport function objectDiff<O extends {}>(a: O, b: O): Diff<keyof O> {\r\n    const aKeys = Object.keys(a) as (keyof O)[];\r\n    const bKeys = Object.keys(b) as (keyof O)[];\r\n    const keyDiff = arrayDiff(aKeys, bKeys);\r\n    const possibleChanges = arrayIntersection(aKeys, bKeys);\r\n    const changes = possibleChanges.filter((k) => a[k] !== b[k]);\r\n\r\n    return { changed: changes, added: keyDiff.added, removed: keyDiff.removed };\r\n}\r\n\r\n/**\r\n * Gets all the key changes (added, removed, or value difference) between\r\n * two objects. Triple equals is used to compare values, not in-depth tree\r\n * checking.\r\n * @param a The first object. Must be defined.\r\n * @param b The second object. Must be defined.\r\n * @returns The keys which have been added, removed, or changed between the\r\n * two objects.\r\n */\r\nexport function objectKeyChanges<O extends {}>(a: O, b: O): (keyof O)[] {\r\n    const diff = objectDiff(a, b);\r\n    return arrayUnion(diff.removed, diff.added, diff.changed);\r\n}\r\n\r\n/**\r\n * Clones an object by running it through JSON parsing. Note that this\r\n * will destroy any complicated object types which do not translate to\r\n * JSON.\r\n * @param obj The object to clone.\r\n * @returns The cloned object\r\n */\r\nexport function objectClone<O extends {}>(obj: O): O {\r\n    return JSON.parse(JSON.stringify(obj));\r\n}\r\n\r\n/**\r\n * Simple object check.\r\n * @param item\r\n * @returns {boolean}\r\n */\r\nexport function isObject(item: any): item is object {\r\n    return item && typeof item === \"object\" && !Array.isArray(item);\r\n}\r\n"],"mappings":"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"}