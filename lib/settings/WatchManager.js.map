{"version":3,"file":"WatchManager.js","names":["IRRELEVANT_ROOM","WatchManager","constructor","_defineProperty2","default","Map","watchSetting","settingName","roomId","cb","watchers","has","set","get","push","unwatchSetting","forEach","map","callbacks","idx","indexOf","splice","notifyUpdate","inRoomId","atLevel","newValueAtLevel","roomWatchers","Array","from","values","flat","callback","exports"],"sources":["../../src/settings/WatchManager.ts"],"sourcesContent":["/*\r\nCopyright 2019 New Vector Ltd.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\nimport { SettingLevel } from \"./SettingLevel\";\r\n\r\nexport type CallbackFn = (changedInRoomId: string | null, atLevel: SettingLevel, newValAtLevel: any) => void;\r\n\r\nconst IRRELEVANT_ROOM: string | null = null;\r\n\r\n/**\r\n * Generalized management class for dealing with watchers on a per-handler (per-level)\r\n * basis without duplicating code. Handlers are expected to push updates through this\r\n * class, which are then proxied outwards to any applicable watchers.\r\n */\r\nexport class WatchManager {\r\n    private watchers = new Map<string, Map<string | null, CallbackFn[]>>(); // settingName -> roomId -> CallbackFn[]\r\n\r\n    // Proxy for handlers to delegate changes to this manager\r\n    public watchSetting(settingName: string, roomId: string | null, cb: CallbackFn): void {\r\n        if (!this.watchers.has(settingName)) this.watchers.set(settingName, new Map());\r\n        if (!this.watchers.get(settingName)!.has(roomId)) this.watchers.get(settingName)!.set(roomId, []);\r\n        this.watchers.get(settingName)!.get(roomId)!.push(cb);\r\n    }\r\n\r\n    // Proxy for handlers to delegate changes to this manager\r\n    public unwatchSetting(cb: CallbackFn): void {\r\n        this.watchers.forEach((map) => {\r\n            map.forEach((callbacks) => {\r\n                let idx: number;\r\n                while ((idx = callbacks.indexOf(cb)) !== -1) {\r\n                    callbacks.splice(idx, 1);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    public notifyUpdate(\r\n        settingName: string,\r\n        inRoomId: string | null,\r\n        atLevel: SettingLevel,\r\n        newValueAtLevel: any,\r\n    ): void {\r\n        // Dev note: We could avoid raising changes for ultimately inconsequential changes, but\r\n        // we also don't have a reliable way to get the old value of a setting. Instead, we'll just\r\n        // let it fall through regardless and let the receiver dedupe if they want to.\r\n\r\n        if (!this.watchers.has(settingName)) return;\r\n\r\n        const roomWatchers = this.watchers.get(settingName)!;\r\n        const callbacks: CallbackFn[] = [];\r\n\r\n        if (inRoomId !== null && roomWatchers.has(inRoomId)) {\r\n            callbacks.push(...roomWatchers.get(inRoomId)!);\r\n        }\r\n\r\n        if (!inRoomId) {\r\n            // Fire updates to all the individual room watchers too, as they probably care about the change higher up.\r\n            callbacks.push(...Array.from(roomWatchers.values()).flat(1));\r\n        } else if (roomWatchers.has(IRRELEVANT_ROOM)) {\r\n            callbacks.push(...roomWatchers.get(IRRELEVANT_ROOM)!);\r\n        }\r\n\r\n        for (const callback of callbacks) {\r\n            callback(inRoomId, atLevel, newValueAtLevel);\r\n        }\r\n    }\r\n}\r\n"],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAMA,MAAMA,eAA8B,GAAG,IAAI;;AAE3C;AACA;AACA;AACA;AACA;AACO,MAAMC,YAAY,CAAC;EAAAC,YAAA;IAAA,IAAAC,gBAAA,CAAAC,OAAA,oBACH,IAAIC,GAAG,CAA2C,CAAC;EAAA;EAAE;EAExE;EACOC,YAAYA,CAACC,WAAmB,EAAEC,MAAqB,EAAEC,EAAc,EAAQ;IAClF,IAAI,CAAC,IAAI,CAACC,QAAQ,CAACC,GAAG,CAACJ,WAAW,CAAC,EAAE,IAAI,CAACG,QAAQ,CAACE,GAAG,CAACL,WAAW,EAAE,IAAIF,GAAG,CAAC,CAAC,CAAC;IAC9E,IAAI,CAAC,IAAI,CAACK,QAAQ,CAACG,GAAG,CAACN,WAAW,CAAC,CAAEI,GAAG,CAACH,MAAM,CAAC,EAAE,IAAI,CAACE,QAAQ,CAACG,GAAG,CAACN,WAAW,CAAC,CAAEK,GAAG,CAACJ,MAAM,EAAE,EAAE,CAAC;IACjG,IAAI,CAACE,QAAQ,CAACG,GAAG,CAACN,WAAW,CAAC,CAAEM,GAAG,CAACL,MAAM,CAAC,CAAEM,IAAI,CAACL,EAAE,CAAC;EACzD;;EAEA;EACOM,cAAcA,CAACN,EAAc,EAAQ;IACxC,IAAI,CAACC,QAAQ,CAACM,OAAO,CAAEC,GAAG,IAAK;MAC3BA,GAAG,CAACD,OAAO,CAAEE,SAAS,IAAK;QACvB,IAAIC,GAAW;QACf,OAAO,CAACA,GAAG,GAAGD,SAAS,CAACE,OAAO,CAACX,EAAE,CAAC,MAAM,CAAC,CAAC,EAAE;UACzCS,SAAS,CAACG,MAAM,CAACF,GAAG,EAAE,CAAC,CAAC;QAC5B;MACJ,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EAEOG,YAAYA,CACff,WAAmB,EACnBgB,QAAuB,EACvBC,OAAqB,EACrBC,eAAoB,EAChB;IACJ;IACA;IACA;;IAEA,IAAI,CAAC,IAAI,CAACf,QAAQ,CAACC,GAAG,CAACJ,WAAW,CAAC,EAAE;IAErC,MAAMmB,YAAY,GAAG,IAAI,CAAChB,QAAQ,CAACG,GAAG,CAACN,WAAW,CAAE;IACpD,MAAMW,SAAuB,GAAG,EAAE;IAElC,IAAIK,QAAQ,KAAK,IAAI,IAAIG,YAAY,CAACf,GAAG,CAACY,QAAQ,CAAC,EAAE;MACjDL,SAAS,CAACJ,IAAI,CAAC,GAAGY,YAAY,CAACb,GAAG,CAACU,QAAQ,CAAE,CAAC;IAClD;IAEA,IAAI,CAACA,QAAQ,EAAE;MACX;MACAL,SAAS,CAACJ,IAAI,CAAC,GAAGa,KAAK,CAACC,IAAI,CAACF,YAAY,CAACG,MAAM,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,CAAC,CAAC;IAChE,CAAC,MAAM,IAAIJ,YAAY,CAACf,GAAG,CAACX,eAAe,CAAC,EAAE;MAC1CkB,SAAS,CAACJ,IAAI,CAAC,GAAGY,YAAY,CAACb,GAAG,CAACb,eAAe,CAAE,CAAC;IACzD;IAEA,KAAK,MAAM+B,QAAQ,IAAIb,SAAS,EAAE;MAC9Ba,QAAQ,CAACR,QAAQ,EAAEC,OAAO,EAAEC,eAAe,CAAC;IAChD;EACJ;AACJ;AAACO,OAAA,CAAA/B,YAAA,GAAAA,YAAA"}