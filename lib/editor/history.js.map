{"version":3,"file":"history.js","names":["MAX_STEP_LENGTH","exports","HistoryManager","constructor","_defineProperty2","default","clear","stack","newlyTypedCharCount","currentIndex","changedSinceLastPush","lastCaret","undefined","nonWordBoundarySinceLastPush","addedSinceLastPush","removedSinceLastPush","shouldPush","inputType","diff","isNonBulkInput","added","removed","str","isWordBoundary","length","pushState","model","caret","pop","parts","serializeParts","push","tryPush","ensureLastChangesPushed","canUndo","canRedo","undo","redo"],"sources":["../../src/editor/history.ts"],"sourcesContent":["/*\r\nCopyright 2019 The Matrix.org Foundation C.I.C.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\nimport EditorModel from \"./model\";\r\nimport { IDiff } from \"./diff\";\r\nimport { SerializedPart } from \"./parts\";\r\nimport { Caret } from \"./caret\";\r\n\r\nexport interface IHistory {\r\n    parts: SerializedPart[];\r\n    caret?: Caret;\r\n}\r\n\r\nexport const MAX_STEP_LENGTH = 10;\r\n\r\nexport default class HistoryManager {\r\n    private stack: IHistory[] = [];\r\n    private newlyTypedCharCount = 0;\r\n    private currentIndex = -1;\r\n    private changedSinceLastPush = false;\r\n    private lastCaret?: Caret;\r\n    private nonWordBoundarySinceLastPush = false;\r\n    private addedSinceLastPush = false;\r\n    private removedSinceLastPush = false;\r\n\r\n    public clear(): void {\r\n        this.stack = [];\r\n        this.newlyTypedCharCount = 0;\r\n        this.currentIndex = -1;\r\n        this.changedSinceLastPush = false;\r\n        this.lastCaret = undefined;\r\n        this.nonWordBoundarySinceLastPush = false;\r\n        this.addedSinceLastPush = false;\r\n        this.removedSinceLastPush = false;\r\n    }\r\n\r\n    private shouldPush(inputType?: string, diff?: IDiff): boolean {\r\n        // right now we can only push a step after\r\n        // the input has been applied to the model,\r\n        // so we can't push the state before something happened.\r\n        // not ideal but changing this would be harder to fit cleanly into\r\n        // the editor model.\r\n        const isNonBulkInput =\r\n            inputType === \"insertText\" || inputType === \"deleteContentForward\" || inputType === \"deleteContentBackward\";\r\n        if (diff && isNonBulkInput) {\r\n            if (diff.added) {\r\n                this.addedSinceLastPush = true;\r\n            }\r\n            if (diff.removed) {\r\n                this.removedSinceLastPush = true;\r\n            }\r\n            // as long as you've only been adding or removing since the last push\r\n            if (this.addedSinceLastPush !== this.removedSinceLastPush) {\r\n                // add steps by word boundary, up to MAX_STEP_LENGTH characters\r\n                const str = diff.added ? diff.added : diff.removed!;\r\n                const isWordBoundary = str === \" \" || str === \"\\t\" || str === \"\\n\";\r\n                if (this.nonWordBoundarySinceLastPush && isWordBoundary) {\r\n                    return true;\r\n                }\r\n                if (!isWordBoundary) {\r\n                    this.nonWordBoundarySinceLastPush = true;\r\n                }\r\n                this.newlyTypedCharCount += str.length;\r\n                return this.newlyTypedCharCount > MAX_STEP_LENGTH;\r\n            } else {\r\n                // if starting to remove while adding before, or the opposite, push\r\n                return true;\r\n            }\r\n        } else {\r\n            // bulk input (paste, ...) should be pushed every time\r\n            return true;\r\n        }\r\n    }\r\n\r\n    private pushState(model: EditorModel, caret?: Caret): void {\r\n        // remove all steps after current step\r\n        while (this.currentIndex < this.stack.length - 1) {\r\n            this.stack.pop();\r\n        }\r\n        const parts = model.serializeParts();\r\n        this.stack.push({ parts, caret });\r\n        this.currentIndex = this.stack.length - 1;\r\n        this.lastCaret = undefined;\r\n        this.changedSinceLastPush = false;\r\n        this.newlyTypedCharCount = 0;\r\n        this.nonWordBoundarySinceLastPush = false;\r\n        this.addedSinceLastPush = false;\r\n        this.removedSinceLastPush = false;\r\n    }\r\n\r\n    // needs to persist parts and caret position\r\n    public tryPush(model: EditorModel, caret?: Caret, inputType?: string, diff?: IDiff): boolean {\r\n        // ignore state restoration echos.\r\n        // these respect the inputType values of the input event,\r\n        // but are actually passed in from MessageEditor calling model.reset()\r\n        // in the keydown event handler.\r\n        if (inputType === \"historyUndo\" || inputType === \"historyRedo\") {\r\n            return false;\r\n        }\r\n        const shouldPush = this.shouldPush(inputType, diff);\r\n        if (shouldPush) {\r\n            this.pushState(model, caret);\r\n        } else {\r\n            this.lastCaret = caret;\r\n            this.changedSinceLastPush = true;\r\n        }\r\n        return shouldPush;\r\n    }\r\n\r\n    public ensureLastChangesPushed(model: EditorModel): void {\r\n        if (this.changedSinceLastPush && this.lastCaret) {\r\n            this.pushState(model, this.lastCaret);\r\n        }\r\n    }\r\n\r\n    public canUndo(): boolean {\r\n        return this.currentIndex >= 1 || this.changedSinceLastPush;\r\n    }\r\n\r\n    public canRedo(): boolean {\r\n        return this.currentIndex < this.stack.length - 1;\r\n    }\r\n\r\n    // returns state that should be applied to model\r\n    public undo(model: EditorModel): IHistory | void {\r\n        if (this.canUndo()) {\r\n            this.ensureLastChangesPushed(model);\r\n            this.currentIndex -= 1;\r\n            return this.stack[this.currentIndex];\r\n        }\r\n    }\r\n\r\n    // returns state that should be applied to model\r\n    public redo(): IHistory | void {\r\n        if (this.canRedo()) {\r\n            this.changedSinceLastPush = false;\r\n            this.currentIndex += 1;\r\n            return this.stack[this.currentIndex];\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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"}