{"version":3,"file":"SlidingRoomListStore.js","names":["_logger","require","_slidingSync","_models","_models2","_AsyncStoreWithClient","_Interface","_spaces","_RoomListStore","_AsyncStore","SlidingSyncSortToFilter","SortAlgorithm","Alphabetic","Recent","Manual","exports","filterConditions","DefaultTagID","Invite","is_invite","Favourite","tags","DM","is_dm","not_tags","Untagged","not_room_types","LowPriority","LISTS_UPDATE_EVENT","RoomListStoreEvent","ListsUpdate","SlidingRoomListStoreClass","AsyncStoreWithClient","constructor","dis","context","_defineProperty2","default","activeSpace","allRoomsInHome","logger","info","tagId","filters","oldSpace","spaces","MetaSpace","Home","undefined","spaceStore","traverseSpace","roomId","push","emit","LISTS_LOADING_EVENT","slidingSyncManager","ensureListRegistered","then","setMaxListeners","setTagSorting","sort","tagIdToSortAlgo","error","getTagSorting","algo","warn","getCount","counts","setListOrder","order","getListOrder","ListAlgorithm","Natural","addFilter","filter","removeFilter","getTagsForRoom","room","listData","slidingSync","getListData","roomIndex","roomIndexToRoomId","manualRoomUpdate","cause","orderedLists","tagMap","refreshOrderedLists","stickyRoomId","roomViewStore","getRoomId","stickyRoomNewIndex","stickyRoomOldIndex","findIndex","orderedRoomIndexes","Object","keys","map","numStr","Number","a","b","seenRoomIds","Set","orderedRoomIds","i","rid","has","add","Error","JSON","stringify","debug","length","inWayRoomId","rooms","forEach","matrixClient","getRoom","onSlidingSyncListUpdate","joinCount","onRoomViewStoreUpdated","hasUpdatedAnyList","oldStickyRoom","list","find","onReady","on","SlidingSyncEvent","List","bind","addListener","UPDATE_EVENT","UPDATE_SELECTED_SPACE","onSelectedSpaceUpdated","OrderedDefaultTagIDs","resetStore","regenerateAllLists","_ref","trigger","onNotReady","onAction","payload","onDispatchAsync"],"sources":["../../../src/stores/room-list/SlidingRoomListStore.ts"],"sourcesContent":["/*\r\nCopyright 2022 The Matrix.org Foundation C.I.C.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\nimport { Room } from \"matrix-js-sdk/src/models/room\";\r\nimport { logger } from \"matrix-js-sdk/src/logger\";\r\nimport { MSC3575Filter, SlidingSyncEvent } from \"matrix-js-sdk/src/sliding-sync\";\r\nimport { Optional } from \"matrix-events-sdk\";\r\n\r\nimport { RoomUpdateCause, TagID, OrderedDefaultTagIDs, DefaultTagID } from \"./models\";\r\nimport { ITagMap, ListAlgorithm, SortAlgorithm } from \"./algorithms/models\";\r\nimport { ActionPayload } from \"../../dispatcher/payloads\";\r\nimport { MatrixDispatcher } from \"../../dispatcher/dispatcher\";\r\nimport { IFilterCondition } from \"./filters/IFilterCondition\";\r\nimport { AsyncStoreWithClient } from \"../AsyncStoreWithClient\";\r\nimport { RoomListStore as Interface, RoomListStoreEvent } from \"./Interface\";\r\nimport { MetaSpace, SpaceKey, UPDATE_SELECTED_SPACE } from \"../spaces\";\r\nimport { LISTS_LOADING_EVENT } from \"./RoomListStore\";\r\nimport { UPDATE_EVENT } from \"../AsyncStore\";\r\nimport { SdkContextClass } from \"../../contexts/SDKContext\";\r\n\r\ninterface IState {\r\n    // state is tracked in underlying classes\r\n}\r\n\r\nexport const SlidingSyncSortToFilter: Record<SortAlgorithm, string[]> = {\r\n    [SortAlgorithm.Alphabetic]: [\"by_name\", \"by_recency\"],\r\n    [SortAlgorithm.Recent]: [\"by_notification_level\", \"by_recency\"],\r\n    [SortAlgorithm.Manual]: [\"by_recency\"],\r\n};\r\n\r\nconst filterConditions: Record<TagID, MSC3575Filter> = {\r\n    [DefaultTagID.Invite]: {\r\n        is_invite: true,\r\n    },\r\n    [DefaultTagID.Favourite]: {\r\n        tags: [\"m.favourite\"],\r\n    },\r\n    // TODO https://github.com/vector-im/element-web/issues/23207\r\n    // DefaultTagID.SavedItems,\r\n    [DefaultTagID.DM]: {\r\n        is_dm: true,\r\n        is_invite: false,\r\n        // If a DM has a Favourite & Low Prio tag then it'll be shown in those lists instead\r\n        not_tags: [\"m.favourite\", \"m.lowpriority\"],\r\n    },\r\n    [DefaultTagID.Untagged]: {\r\n        is_dm: false,\r\n        is_invite: false,\r\n        not_room_types: [\"m.space\"],\r\n        not_tags: [\"m.favourite\", \"m.lowpriority\"],\r\n        // spaces filter added dynamically\r\n    },\r\n    [DefaultTagID.LowPriority]: {\r\n        tags: [\"m.lowpriority\"],\r\n        // If a room has both Favourite & Low Prio tags then it'll be shown under Favourites\r\n        not_tags: [\"m.favourite\"],\r\n    },\r\n    // TODO https://github.com/vector-im/element-web/issues/23207\r\n    // DefaultTagID.ServerNotice,\r\n    // DefaultTagID.Suggested,\r\n    // DefaultTagID.Archived,\r\n};\r\n\r\nexport const LISTS_UPDATE_EVENT = RoomListStoreEvent.ListsUpdate;\r\n\r\nexport class SlidingRoomListStoreClass extends AsyncStoreWithClient<IState> implements Interface {\r\n    private tagIdToSortAlgo: Record<TagID, SortAlgorithm> = {};\r\n    private tagMap: ITagMap = {};\r\n    private counts: Record<TagID, number> = {};\r\n    private stickyRoomId: Optional<string>;\r\n\r\n    public constructor(dis: MatrixDispatcher, private readonly context: SdkContextClass) {\r\n        super(dis);\r\n        this.setMaxListeners(20); // RoomList + LeftPanel + 8xRoomSubList + spares\r\n    }\r\n\r\n    public async setTagSorting(tagId: TagID, sort: SortAlgorithm): Promise<void> {\r\n        logger.info(\"SlidingRoomListStore.setTagSorting \", tagId, sort);\r\n        this.tagIdToSortAlgo[tagId] = sort;\r\n        switch (sort) {\r\n            case SortAlgorithm.Alphabetic:\r\n                await this.context.slidingSyncManager.ensureListRegistered(tagId, {\r\n                    sort: SlidingSyncSortToFilter[SortAlgorithm.Alphabetic],\r\n                });\r\n                break;\r\n            case SortAlgorithm.Recent:\r\n                await this.context.slidingSyncManager.ensureListRegistered(tagId, {\r\n                    sort: SlidingSyncSortToFilter[SortAlgorithm.Recent],\r\n                });\r\n                break;\r\n            case SortAlgorithm.Manual:\r\n                logger.error(\"cannot enable manual sort in sliding sync mode\");\r\n                break;\r\n            default:\r\n                logger.error(\"unknown sort mode: \", sort);\r\n        }\r\n    }\r\n\r\n    public getTagSorting(tagId: TagID): SortAlgorithm {\r\n        let algo = this.tagIdToSortAlgo[tagId];\r\n        if (!algo) {\r\n            logger.warn(\"SlidingRoomListStore.getTagSorting: no sort algorithm for tag \", tagId);\r\n            algo = SortAlgorithm.Recent; // why not, we have to do something..\r\n        }\r\n        return algo;\r\n    }\r\n\r\n    public getCount(tagId: TagID): number {\r\n        return this.counts[tagId] || 0;\r\n    }\r\n\r\n    public setListOrder(tagId: TagID, order: ListAlgorithm): void {\r\n        // TODO: https://github.com/vector-im/element-web/issues/23207\r\n    }\r\n\r\n    public getListOrder(tagId: TagID): ListAlgorithm {\r\n        // TODO: handle unread msgs first? https://github.com/vector-im/element-web/issues/23207\r\n        return ListAlgorithm.Natural;\r\n    }\r\n\r\n    /**\r\n     * Adds a filter condition to the room list store. Filters may be applied async,\r\n     * and thus might not cause an update to the store immediately.\r\n     * @param {IFilterCondition} filter The filter condition to add.\r\n     */\r\n    public async addFilter(filter: IFilterCondition): Promise<void> {\r\n        // Do nothing, the filters are only used by SpaceWatcher to see if a room should appear\r\n        // in the room list. We do not support arbitrary code for filters in sliding sync.\r\n    }\r\n\r\n    /**\r\n     * Removes a filter condition from the room list store. If the filter was\r\n     * not previously added to the room list store, this will no-op. The effects\r\n     * of removing a filter may be applied async and therefore might not cause\r\n     * an update right away.\r\n     * @param {IFilterCondition} filter The filter condition to remove.\r\n     */\r\n    public removeFilter(filter: IFilterCondition): void {\r\n        // Do nothing, the filters are only used by SpaceWatcher to see if a room should appear\r\n        // in the room list. We do not support arbitrary code for filters in sliding sync.\r\n    }\r\n\r\n    /**\r\n     * Gets the tags for a room identified by the store. The returned set\r\n     * should never be empty, and will contain DefaultTagID.Untagged if\r\n     * the store is not aware of any tags.\r\n     * @param room The room to get the tags for.\r\n     * @returns The tags for the room.\r\n     */\r\n    public getTagsForRoom(room: Room): TagID[] {\r\n        // check all lists for each tag we know about and see if the room is there\r\n        const tags: TagID[] = [];\r\n        for (const tagId in this.tagIdToSortAlgo) {\r\n            const listData = this.context.slidingSyncManager.slidingSync.getListData(tagId);\r\n            if (!listData) {\r\n                continue;\r\n            }\r\n            for (const roomIndex in listData.roomIndexToRoomId) {\r\n                const roomId = listData.roomIndexToRoomId[roomIndex];\r\n                if (roomId === room.roomId) {\r\n                    tags.push(tagId);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return tags;\r\n    }\r\n\r\n    /**\r\n     * Manually update a room with a given cause. This should only be used if the\r\n     * room list store would otherwise be incapable of doing the update itself. Note\r\n     * that this may race with the room list's regular operation.\r\n     * @param {Room} room The room to update.\r\n     * @param {RoomUpdateCause} cause The cause to update for.\r\n     */\r\n    public async manualRoomUpdate(room: Room, cause: RoomUpdateCause): Promise<void> {\r\n        // TODO: this is only used when you forget a room, not that important for now.\r\n    }\r\n\r\n    public get orderedLists(): ITagMap {\r\n        return this.tagMap;\r\n    }\r\n\r\n    private refreshOrderedLists(tagId: string, roomIndexToRoomId: Record<number, string>): void {\r\n        const tagMap = this.tagMap;\r\n\r\n        // this room will not move due to it being viewed: it is sticky. This can be null to indicate\r\n        // no sticky room if you aren't viewing a room.\r\n        this.stickyRoomId = this.context.roomViewStore.getRoomId();\r\n        let stickyRoomNewIndex = -1;\r\n        const stickyRoomOldIndex = (tagMap[tagId] || []).findIndex((room): boolean => {\r\n            return room.roomId === this.stickyRoomId;\r\n        });\r\n\r\n        // order from low to high\r\n        const orderedRoomIndexes = Object.keys(roomIndexToRoomId)\r\n            .map((numStr) => {\r\n                return Number(numStr);\r\n            })\r\n            .sort((a, b) => {\r\n                return a - b;\r\n            });\r\n        const seenRoomIds = new Set<string>();\r\n        const orderedRoomIds = orderedRoomIndexes.map((i) => {\r\n            const rid = roomIndexToRoomId[i];\r\n            if (seenRoomIds.has(rid)) {\r\n                logger.error(\"room \" + rid + \" already has an index position: duplicate room!\");\r\n            }\r\n            seenRoomIds.add(rid);\r\n            if (!rid) {\r\n                throw new Error(\"index \" + i + \" has no room ID: Map => \" + JSON.stringify(roomIndexToRoomId));\r\n            }\r\n            if (rid === this.stickyRoomId) {\r\n                stickyRoomNewIndex = i;\r\n            }\r\n            return rid;\r\n        });\r\n        logger.debug(\r\n            `SlidingRoomListStore.refreshOrderedLists ${tagId} sticky: ${this.stickyRoomId}`,\r\n            `${stickyRoomOldIndex} -> ${stickyRoomNewIndex}`,\r\n            \"rooms:\",\r\n            orderedRoomIds.length < 30 ? orderedRoomIds : orderedRoomIds.length,\r\n        );\r\n\r\n        if (this.stickyRoomId && stickyRoomOldIndex >= 0 && stickyRoomNewIndex >= 0) {\r\n            // this update will move this sticky room from old to new, which we do not want.\r\n            // Instead, keep the sticky room ID index position as it is, swap it with\r\n            // whatever was in its place.\r\n            // Some scenarios with sticky room S and bump room B (other letters unimportant):\r\n            // A, S, C, B                                  S, A, B\r\n            // B, A, S, C  <---- without sticky rooms ---> B, S, A\r\n            // B, S, A, C  <- with sticky rooms applied -> S, B, A\r\n            // In other words, we need to swap positions to keep it locked in place.\r\n            const inWayRoomId = orderedRoomIds[stickyRoomOldIndex];\r\n            orderedRoomIds[stickyRoomOldIndex] = this.stickyRoomId;\r\n            orderedRoomIds[stickyRoomNewIndex] = inWayRoomId;\r\n        }\r\n\r\n        // now set the rooms\r\n        const rooms: Room[] = [];\r\n        orderedRoomIds.forEach((roomId) => {\r\n            const room = this.matrixClient?.getRoom(roomId);\r\n            if (!room) {\r\n                return;\r\n            }\r\n            rooms.push(room);\r\n        });\r\n        tagMap[tagId] = rooms;\r\n        this.tagMap = tagMap;\r\n    }\r\n\r\n    private onSlidingSyncListUpdate(tagId: string, joinCount: number, roomIndexToRoomId: Record<number, string>): void {\r\n        this.counts[tagId] = joinCount;\r\n        this.refreshOrderedLists(tagId, roomIndexToRoomId);\r\n        // let the UI update\r\n        this.emit(LISTS_UPDATE_EVENT);\r\n    }\r\n\r\n    private onRoomViewStoreUpdated(): void {\r\n        // we only care about this to know when the user has clicked on a room to set the stickiness value\r\n        if (this.context.roomViewStore.getRoomId() === this.stickyRoomId) {\r\n            return;\r\n        }\r\n\r\n        let hasUpdatedAnyList = false;\r\n\r\n        // every list with the OLD sticky room ID needs to be resorted because it now needs to take\r\n        // its proper place as it is no longer sticky. The newly sticky room can remain the same though,\r\n        // as we only actually care about its sticky status when we get list updates.\r\n        const oldStickyRoom = this.stickyRoomId;\r\n        // it's not safe to check the data in slidingSync as it is tracking the server's view of the\r\n        // room list. There's an edge case whereby the sticky room has gone outside the window and so\r\n        // would not be present in the roomIndexToRoomId map anymore, and hence clicking away from it\r\n        // will make it disappear eventually. We need to check orderedLists as that is the actual\r\n        // sorted renderable list of rooms which sticky rooms apply to.\r\n        for (const tagId in this.orderedLists) {\r\n            const list = this.orderedLists[tagId];\r\n            const room = list.find((room) => {\r\n                return room.roomId === oldStickyRoom;\r\n            });\r\n            if (room) {\r\n                // resort it based on the slidingSync view of the list. This may cause this old sticky\r\n                // room to cease to exist.\r\n                const listData = this.context.slidingSyncManager.slidingSync.getListData(tagId);\r\n                if (!listData) {\r\n                    continue;\r\n                }\r\n                this.refreshOrderedLists(tagId, listData.roomIndexToRoomId);\r\n                hasUpdatedAnyList = true;\r\n            }\r\n        }\r\n        // in the event we didn't call refreshOrderedLists, it helps to still remember the sticky room ID.\r\n        this.stickyRoomId = this.context.roomViewStore.getRoomId();\r\n\r\n        if (hasUpdatedAnyList) {\r\n            this.emit(LISTS_UPDATE_EVENT);\r\n        }\r\n    }\r\n\r\n    protected async onReady(): Promise<any> {\r\n        logger.info(\"SlidingRoomListStore.onReady\");\r\n        // permanent listeners: never get destroyed. Could be an issue if we want to test this in isolation.\r\n        this.context.slidingSyncManager.slidingSync.on(SlidingSyncEvent.List, this.onSlidingSyncListUpdate.bind(this));\r\n        this.context.roomViewStore.addListener(UPDATE_EVENT, this.onRoomViewStoreUpdated.bind(this));\r\n        this.context.spaceStore.on(UPDATE_SELECTED_SPACE, this.onSelectedSpaceUpdated.bind(this));\r\n        if (this.context.spaceStore.activeSpace) {\r\n            this.onSelectedSpaceUpdated(this.context.spaceStore.activeSpace, false);\r\n        }\r\n\r\n        // sliding sync has an initial response for spaces. Now request all the lists.\r\n        // We do the spaces list _first_ to avoid potential flickering on DefaultTagID.Untagged list\r\n        // which would be caused by initially having no `spaces` filter set, and then suddenly setting one.\r\n        OrderedDefaultTagIDs.forEach((tagId) => {\r\n            const filter = filterConditions[tagId];\r\n            if (!filter) {\r\n                logger.info(\"SlidingRoomListStore.onReady unsupported list \", tagId);\r\n                return; // we do not support this list yet.\r\n            }\r\n            const sort = SortAlgorithm.Recent; // default to recency sort, TODO: read from config\r\n            this.tagIdToSortAlgo[tagId] = sort;\r\n            this.emit(LISTS_LOADING_EVENT, tagId, true);\r\n            this.context.slidingSyncManager\r\n                .ensureListRegistered(tagId, {\r\n                    filters: filter,\r\n                    sort: SlidingSyncSortToFilter[sort],\r\n                })\r\n                .then(() => {\r\n                    this.emit(LISTS_LOADING_EVENT, tagId, false);\r\n                });\r\n        });\r\n    }\r\n\r\n    private onSelectedSpaceUpdated = (activeSpace: SpaceKey, allRoomsInHome: boolean): void => {\r\n        logger.info(\"SlidingRoomListStore.onSelectedSpaceUpdated\", activeSpace);\r\n        // update the untagged filter\r\n        const tagId = DefaultTagID.Untagged;\r\n        const filters = filterConditions[tagId];\r\n        const oldSpace = filters.spaces?.[0];\r\n        filters.spaces = activeSpace && activeSpace != MetaSpace.Home ? [activeSpace] : undefined;\r\n        if (oldSpace !== activeSpace) {\r\n            // include subspaces in this list\r\n            this.context.spaceStore.traverseSpace(\r\n                activeSpace,\r\n                (roomId: string) => {\r\n                    if (roomId === activeSpace) {\r\n                        return;\r\n                    }\r\n                    if (!filters.spaces) {\r\n                        filters.spaces = [];\r\n                    }\r\n                    filters.spaces.push(roomId); // add subspace\r\n                },\r\n                false,\r\n            );\r\n\r\n            this.emit(LISTS_LOADING_EVENT, tagId, true);\r\n            this.context.slidingSyncManager\r\n                .ensureListRegistered(tagId, {\r\n                    filters: filters,\r\n                })\r\n                .then(() => {\r\n                    this.emit(LISTS_LOADING_EVENT, tagId, false);\r\n                });\r\n        }\r\n    };\r\n\r\n    // Intended for test usage\r\n    public async resetStore(): Promise<void> {\r\n        // Test function\r\n    }\r\n\r\n    /**\r\n     * Regenerates the room whole room list, discarding any previous results.\r\n     *\r\n     * Note: This is only exposed externally for the tests. Do not call this from within\r\n     * the app.\r\n     * @param trigger Set to false to prevent a list update from being sent. Should only\r\n     * be used if the calling code will manually trigger the update.\r\n     */\r\n    public regenerateAllLists({ trigger = true }): void {\r\n        // Test function\r\n    }\r\n\r\n    protected async onNotReady(): Promise<any> {\r\n        await this.resetStore();\r\n    }\r\n\r\n    protected async onAction(payload: ActionPayload): Promise<void> {}\r\n\r\n    protected async onDispatchAsync(payload: ActionPayload): Promise<void> {}\r\n}\r\n"],"mappings":"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"}